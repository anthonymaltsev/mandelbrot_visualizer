; out_of bounds
(cond
  	[(or (<(real c)(- 0 (/ width 2))) (>(real c)(/ width 2)) ) #f]
    [(or (<(imag c)(- 0 (/ height 2))) (>(imag c)(/ height 2)) ) #f]
    [else #t]
  )

;draw
(ht)
  (pixelsize 5)
  (pixel 0 0 "black")
  (pixel 1 1 "blue")
  (pixel 2 2 "gray")
  (pixel 50 50 "black")

  (define (forwidth width_left) ; loop through the width of the image
    
    (define (forheight height_left) ; loop through the height of the image
       
      (pixel (- width width_left) (- height height_left) "gray") ; this is the bit that actually draws anything
      
      (if (> height_left 0)
        (forheight (- height_left 1) )
        (void)
      )
      
    )
    (forheight height)
    (if (> width_left 0)
      (forwidth (- width_left 1))
      (void)
    )
    
  )
  (forwidth width)

;draw 2
(ht)
  (pu)(goto (- 500) (- 500) ) (pd)
  (pixelsize 1)
  
  (define (outer n m)
    
    (define (inner m)
      (if (= m height)
        (pixel n m (color_of orbits (- width width_left) (- height height_left)))
        (begin (pixel n m (color_of orbits (- width width_left) (- height height_left))) (inner (+ m 1)))
      )
    )
    
    (if (= n width)
      (inner m)
      (begin (inner m) (outer (+ n 1) m))
    )
  )
  

  (outer 0 0)

;draw 3
(ht)
  (bgcolor "black")


  (define (inner orbit)
    (if (null? (cdr orbit))
      (pixel (* (quotient width 2) (car (car orbit))) (* (quotient height 2) (car (cdr (car orbit)))) "white")
      (begin (pixel (* (quotient width 2) (car (car orbit))) (* (quotient height 2) (car (cdr (car orbit)))) "white") (inner (cdr orbit)))
    )
  )
  (define (loop inputs) 
    (if(null? (cdr inputs))
      (inner (orbitof (car inputs)))
      (begin (inner (orbitof (car inputs))) (loop (cdr inputs)))
    )
  )

  (define (test in n)
    (if (= n 0)
      (inner (orbitof (candr in n)))
      (begin (inner (orbitof (candr in n))) (test in (- n 1)))
    )
  )

  (test inputs 3)
  ;(loop inputs)

; first orbitof
; return a list with all of the elements being positions that starting compl number c reaches by recursing z^2+c
(define (orbitof c)
	(define (helper z iters)
  	(cond [(= iters 0) nil]
    			[(out_of_bounds z) nil]
          [else (cons z (helper (cadd (csq z) c) (- iters 1)))]
    )
  )
  (helper c max_iter)
)
;draw 4
(define (draworb orbit)
    (if (null? (cdr orbit))
      (pixel (* (quotient width 2) (car (car orbit))) (* (quotient height 2) (car (cdr (car orbit)))) "white")
      (begin (pixel (* (quotient width 2) (car (car orbit))) (* (quotient height 2) (car (cdr (car orbit)))) "white") (draworb (cdr orbit)))
    )
  )
(define (test in n)
    (if (= n 0)
      (draworb (orbitof (car in)))
      (begin (draworb (orbitof (candr in n))) (test in (- n 1)))
    )
  )

;draw closest to final
(define (forwidth width_left) ; loop through the width of the image
    
    (define (forheight height_left) ; loop through the height of the image
       
      (pixel (+ (- (quotient width 2)) (- width width_left))
             (+ (- (quotient height 2)) (- height height_left))
              (rgb (+ 0.5 (/ width_left 400))
                   (+ 0.5 (/ height_left 400))
                   0
              )
      )
             ;(color_of finalorbits (+ (- (quotient width 2)) (- width width_left)) (+ (- (quotient height 2)) (- height height_left)) )) 
      
      (if (> height_left 0)
        (forheight (- height_left 1) )
        nil
      )
      
    )
    (forheight height)
    (if (> width_left 0)
      (forwidth (- width_left 1))
      nil
    )
    
  )
  (forwidth width)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;utilities
; convert a given list of input points (complex numbers near the edge of the mandelbrot) into their orbitals
(define (get_orbits inputs)
  (if (null? inputs) 
    nil
    (cons (orbitof (car inputs)) (get_orbits (cdr inputs)))
  )
)

; check if a given orbital passes through in a square(pixel) --> returns nat number with number of times it passes through given square
(define (in_square orbit x y)
  (cond
    [(null? orbit) 0]
    [(or (< (real (car orbit)) (+ (- 0 2) (/ x pixel_width))) (> (real (car orbit)) (+ (- 0 2) (/ (+ x 1) pixel_width))) ) 
      (+ 0 (in_square (cdr orbit) x y)) ] ; check real
    [(or (> (imag (car orbit)) (- 2 (/ y pixel_height))) (< (imag (car orbit)) (- 2 (/ (+ y 1) pixel_height))) )  
      (+ 0 (in_square (cdr orbit) x y)) ] ; check imag
    [else 
      (+ 1 (in_square (cdr orbit) x y))]
  )
)

; check tot number of times an orbital passes through a square
(define (num_thru_square orbits x y)
  (if (null? orbits) 
    0
    (+ (in_square (car orbits) x y) (num_thru_square (cdr orbits) x y))
  )
)

; return the color of the pixel based on how many times it was passed through
(define (color_of orbits x y)
  (let ((fraction (/ (num_thru_square orbits x y) 10)))
  (if (> fraction 1)
    (rgb 1 1 1)
    (rgb fraction fraction fraction)
  )
  )
)

;draw color

(define (pr_color c )
  (let 
    (
      (r (+ 0.5 (* 0.5 (abs (sin (* 100000000 (real c)))))))
      (g (+ 0.5 (* 0.5 (abs (sin (* 100000000 (real c)))))))
      (b (+ 0.5 (* 0.5 (abs (sin (+ (* 100000000 (real c)) (* 100000000 (imag c))))))))
    )
    (rgb r g b)
  )
)
